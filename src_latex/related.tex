\section{Related Work}\label{sec:related}
In this section, we discuss the related literature on code smell and JavaScript systems.
Code Smells~\cite{fowler1997refactoring} are poor design and implementation choices that are reported to negatively impact the quality of software systems. They are opposite to design patterns~\cite{Gam95} which are good solutions to recurrent design problems.
%Other researches have been done on Javascript before. Most of the previous studies on Javascript have been done on client side security of Javascript applications. Saxena \ea developed a system to explore the execution space of client side Javascript applications to find security vulnerabilities \cite{saxena2010symbolic}. On the other study, they proposed a dynamic analysis technique to discover validation vulnerabilities in client side Javascript applications systematically \cite{saxena2010flax}. Richards \ea studied the dynamic behavior of Javascript by performing an empirical study on how and why the dynamic features of Javascript are being used \cite{richards2010analysis}. Bielova conducted a survey on Javascript security policies for client side applications and proposed a detailed comparision of the runtime monitoring based security technique for Javascript applications \cite{bielova2013survey}. Tripp and Weisman presented a hybrid-analysis solution to automate the assessment of Javascript client side application by combining white-box and black-box methodologies \cite{tripp2011hybrid}. Hallaraker \ea also proposed an approach based on monitoring Javascript code execution to detect malicious code behavior \cite{hallaraker2005detecting}.
The literature related to code smells generally falls into three categories: (1) the detection of code smells~(e.g.,~\cite{Khomh11-BGB,fard2013jsnose}); (2) the evolution of code smells in software systems (e.g.,~\cite{chatzigeorgiou2010investigating,CodeSmells_overtime,peters2012evaluating,tufano2015and}) and their impact on software quality (e.g., ~\cite{shatnawi2006investigation,khomh2012exploratory,Abbes11,jaafar2013mining,tufano2015and});
and (3) the relationship between code smells and software development activities (e.g.,~\cite{Sjoberg13QEC,Abbes11}).

Our work in this paper, {\color{blue}strongly related to the one of Amir Saboury et al.~\cite{saboury2017empirical}}, falls into the second category. We aim to understand how code smells affect the fault-proneness of JavaScript systems. Li and Shatnawi~\cite{shatnawi2006investigation} who investigated the relationships between code smells and the occurrence of errors in the code of three different versions of Eclipse reported that code smells are positively associated with higher error probability. In the same line of study, Khomh et al.~\cite{khomh2012exploratory} investigated the relationship between code smells and the change- and fault-proneness of 54 releases of four popular Java open source systems (ArgoUML, Eclipse, Mylyn and Rhino). They observed that classes with code smells tend to be more change- and fault-prone than other classes. Tufano et al. \cite{tufano2015and} investigated the evolution of code smells in 200 open source Java systems from Android, Apache, and Eclipse ecosystems and found that code smells are often introduced in the code at the beginning of the projects, by both newcomers and experienced developers. Sjoberg et al.~\cite{Sjoberg13QEC}, who investigated the relationship between code smells and maintenance effort reported that code smells have a limited impact on maintenance effort. However, Abbes et al.~\cite{Abbes11} found that code smells can have a negative impact on code understandability. Recently, Fard et al. \cite{fard2013jsnose} have proposed a technique named JNOSE to detect 13 different types of code smells in JavaScript systems. The proposed technique combines static and dynamic analysis. They applied JNOSE on 11 client-web applications and found ``lazy object" and ``long method/function" to be the most frequent code smells in the systems. WebScent~\cite{nguyen2012detection} is another tool that can detect client-side smells. It identifies mixing of HTML, CSS, and JavaScript, duplicate code in JavaScript, and HTML syntax errors. ESLint \cite{ESLint}, JSLint \cite{JslinT} and JSHint \cite{JSHint} are rule based static code analysis tools that can validate source codes against a set of best coding practices. Despite this interest in JavaScript code smells and the growing popularity of JavaScript systems, to the best of our knowledge, there is no study that examined the effect of code smells on the fault-proneness of JavaScript server-side projects. This paper aims to fill this gap. 

%These previous studies raised the awareness of the community about the potential negative impact of code smells on the quality of object oriented systems and recommended that developers apply refactorings to remove code smells from their systems. %of y recommend applying refactoring to remove such interactions of anti-patterns.

%Jaafar et al.~\cite{jaafar2013mining} examined the fault-proneness of classes sharing a static or a co-change relationship with a class containing a code smell and reported hat  an empirical study to analyze anti-patterns dependencies in more than 165000 commits of three Java open source software (ArgoUML, JFreeChart, and XerecesJ). They showed that, classes that have static relationship as well as the classes that have co-change relationship with anti-patterns are more likely to be fault-prone than others.

%and smelliness happens as a consequence of evolution and maintenance activities which can even be introduced by refactoring operations.  al.~\cite{Khomh:2012:ESI:2158916.2158921} show that there is a relation between antipatterns and the bug-proneness of a file. These studies provide empirical evidences on the relation between antipatterns and bugs.
%Khomh et al. \cite{khomh2012exploratory} who investigated the relationship between the presence of code smells and software change- and fault-proneness
%Tufano et al. \cite{tufano2015and} studied a large change history of 200 open source projects in Java (Android, Apache and Eclipse) and found that code smells can be formed since the beginning of a project by both newcomers and experienced deveopers and smelliness happens as a consequence of evolution and maintenance activities which can even be introduced by refactoring operations. Khomh et al. \cite{khomh2012exploratory} investigated the relationship between the presence of anti-patterns and software change- and fault-proneness on 54 releases of four popular Java open source systems (ArgoUML, Eclipse, Mylyn and Rhino). They discovered that classes with code smells tend to be more change-and fault-prone than the other classes. Jaafar et al. \cite{jaafar2013mining} conducted an empirical study to analyze anti-patterns dependencies in more than 165000 commits of three Java open source software (ArgoUML, JFreeChart, and XerecesJ). They showed that, classes that have static relationship as well as the classes that have co-change relationship with anti-patterns are more likely to be fault-prone than others.

%On the other hand, less studies aimed the quality and maintainability of Javascript applications \cite{nguyen2012detection}.
%A number of efforts have been done on tools that assist developers to better maintain their web applications. JSLint \cite{JslinT} is a static code analysis tool that can validate source codes against a set of best code practices. In a more closely related work, Fard et al. \cite{fard2013jsnose} proposed a technique that combines static with dynamic analysis to detect 13 different types of code smells. They applied their JNOSE on 11 web applications an found that ``lazy object" and ``long method/function" are amongst the most frequent code smells. WebScent ~\cite{nguyen2012detection} detects client-side smells and basically identifies mixing of HTML, CSS, and JavaScript, duplicate code in JavaScript, and HTML syntax error.
%
%However, non of mentioned works have examined the effect of code smells on a very important aspect of software, i.e., fault-proneness in JavaScript projects.

%Gizas \ea compared the latest release of 7 popular client side Javascript libraries and reported their overall quality, performance and validity \cite{gizas2012comparative}. Those studies however are only focused on the client side Javascript application.
%In this paper, we analyzed the quality of server side JavaScript applications and conduct an empirical study on five popular server side JavaScript frameworks over 537 releases to explore the survival of smelly codes in terms of catching software bugs.

%In the following sections we introduce the concept of NodeJS and NPM and discuss why this platform needs more attention in the researchers' community.

%\subsection*{JavaScript and Nodejs}
%\mytitle{JavaScript and Nodejs} JavaScript is a powerful, flexible and popular scripting programming language. It is the most commonly used programming language on both front-end and back-end with more than 90\% usage on the front-end and more than 54\% on the back-end \cite{so:survay2016}. It also has the most active repositories and total pushes on Github \cite{githut}.
%\Foutse{The systems investigated in this paper use NodeJS and NPM?} \Foutse{we need to explain why it is important to know these two concepts otherwise we should remove them...right now its not clear to me if they are useful for understanding the work presented in the paper, Amir please exlain.....}
%\mytitle{Nodejs} (also called Node) is an open source platform to run JavaScript on the server side. The core is based on Google's JavaScript runtime engine called V8. Node and V8 are mostly written in C and C++. Although V8 mainly supports running client-side JavaScript codes, Node uses its power to support long-running, real-time, scalable and memory efficient server-side network applications \cite{tilkov2010node}. Node is also famous for its event-driven nature and non-blocking I/O model, which makes it a perfect fit for data-intensive and network applications. On the first quarter of 2015, Joyent, IBM, Microsoft, PayPal, Fidelity, SAP and The Linux Foundation joined forces to bring neutral and open governance support to the Node community \cite{nodeFoundation}. The growing popularity of JavaScript raises the demand for good design practices and style-guides.

%\subsection*{NPM}
%\mytitle{NPM} Nodejs comes with its own package manager called NPM (Node Package Manager). NPM enables developers to install community libraries and their dependencies easily through the command-line interface \cite{tilkov2010node}. By the time of writing this paper, there are more than 310,000 distinct modules registered on NPM. With average growth rate of more than 400 modules per day, it is the most popular registry on the web \cite{modulecounts}. This shows how the popularity of using community libraries are increasing. NPm has increased the usage of community libraries drastically, thanks to its simple and easy to use APIs. % of NPM increased the usage of using community libraries drastically.
%Developers can add third-party modules as dependency of their application using simple commands. But, this raises the questions about the quality and security of those modules. In March 2016, a developer removed all of his modules from NPM. One of the modules called \texttt{left-pad}\footnote{https://www.npmjs.com/package/left-pad} had been used by thousands of other modules living in NPM. The removal of this small module with only 11 lines of code, broke thousands of other modules \cite{reg2016lp, med2016lp}. This event was a strong illustration of the impact that community modules can have on JavaScript applications. %is indicates how the security and quality of community modules impact JavaScript applications.


